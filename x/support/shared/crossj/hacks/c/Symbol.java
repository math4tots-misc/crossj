package crossj.hacks.c;

import crossj.base.List;

/**
 * A C Symbol and associated data.
 */
public final class Symbol {
    /**
     * The name of this symbol.
     */
    private final String name;

    /**
     * See the Scope class for possible values.
     */
    private final int scope;

    /**
     * The place where this symbol was defined.
     *
     * Fraser and Hanson's book uses he field name 'src' and a struct named
     * 'Coordinate'.
     */
    private final Mark mark;

    /**
     * This field chains together all Symbols in a SymbolTable starting with the
     * last one installed.
     *
     * Traversing up this chain reveals all of the symbols that are in scope at the
     * time of the traversal, as well as those hidden by declarations of the same
     * identifiers in nested scopes.
     */
    private Symbol up = null;

    /**
     * List of places where this symbol is used.
     *
     * TODO: Use a "Usage" class with context information instead of just a Mark.
     */
    private final List<Mark> uses;

    /**
     * Symbol's extended storage class.
     *
     * See the StorageClass class for possible values.
     */
    private final int storageClass;

    /**
     * Holds the Type for variables, functions, constants, and structure, union, and
     * enumeration types.
     */
    private final Type type;

    private boolean generated = false;

    private LabelInfo labelInfo;

    private Symbol(String name, int scope, Mark mark, List<Mark> uses, int storageClass, Type type) {
        this.name = name;
        this.scope = scope;
        this.mark = mark;
        this.uses = uses;
        this.storageClass = storageClass;
        this.type = type;
    }

    public static Symbol of(String name, int scope, Mark mark, List<Mark> uses, int storageClass,
            Type type) {
        return new Symbol(name, scope, mark, uses, storageClass, type);
    }

    /**
     * The name of this symbol.
     */
    public String getName() {
        return name;
    }

    /**
     * The scope in which this symbol was declared.
     *
     * See the Scope class for possible values.
     */
    public int getScope() {
        return scope;
    }

    /**
     * Mark indicating location in source where this symbol was first declared.
     */
    public Mark getMark() {
        return mark;
    }

    /**
     * Gets the next Symbol in the linked list of all Symbols in a given
     * SymbolTable.
     *
     * May return null if this is the last Symbol in the SymbolTable.
     */
    public Symbol getUp() {
        return up;
    }

    public void setUp(Symbol up) {
        this.up = up;
    }

    public List<Mark> getUses() {
        return uses;
    }

    /**
     * The Symbol's extended storage class.
     *
     * See the StorageClass class for possible values.
     */
    public int getStorageClass() {
        return storageClass;
    }

    /**
     * Get the type for variables, functions, constants, and structure, union and
     * enumeration types.
     *
     * Not set or meaningful for other kinds of symbols.
     */
    public Type getType() {
        return type;
    }

    public void setGenerated(boolean generated) {
        this.generated = generated;
    }

    /**
     * Flag indicating whether this Symbol was generated by the compiler.
     */
    public boolean isGenerated() {
        return generated;
    }

    /**
     * Extra data for when this Symbol represents a Label.
     */
    public LabelInfo getLabelInfo() {
        return labelInfo;
    }

    public void setLabelInfo(LabelInfo labelInfo) {
        this.labelInfo = labelInfo;
    }
}
