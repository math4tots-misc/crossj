#!/usr/local/bin/python3
#
# Package asset data into generated java files.
#
from os.path import join, dirname, realpath, relpath, sep, basename
import os
import argparse


def main():
    parser = argparse.ArgumentParser(description="package assets into Java files")
    parser.add_argument('roots', nargs='*', help='Java source roots to look for assets in')
    parser.add_argument(
        '--out',
        '-o',
        default=join('out', 'generated'),
        help='output directory (defaults to out/generated)',
    )
    parser.add_argument('--verbose', '-v', action='count', default=0)
    parser.add_argument('--use-gdx-default-roots', action='store_true', default=False)
    parser.add_argument('--use-java-default-roots', action='store_true', default=False)
    parser.add_argument('--use-js-default-roots', action='store_true', default=False)
    args = parser.parse_args()
    verbose: int = args.verbose
    outdir: str = args.out
    roots = list(args.roots)
    if args.use_gdx_default_roots:
        roots.extend([
            'support/shared',
            'support/java',
            'support/gdx',
        ])
    if args.use_java_default_roots:
        roots.extend([
            'support/shared',
            'support/java',
        ])
    if args.use_js_default_roots:
        roots.extend([
            'support/shared',
            'support/js',
        ])
    count = 0
    for root in roots:
        for dirpath, _dirnames, filenames in os.walk(root):
            for filename in filenames:
                filepath = join(dirpath, filename)
                count += translate(filepath, root, outdir, verbose)
    if verbose:
        print(f'processed {count} files')


def translate(path:str, root: str, outdir: str, verbose: bool):
    outpath = compute_outpath(path, root, outdir)
    if outpath is None:
        return False
    os.makedirs(dirname(outpath), exist_ok=True)

    pkg = compute_pkg(path, root)
    shortname = compute_shortname(path)

    if verbose:
        print(f'processing {path} ({pkg}.{shortname})')

    with open(outpath, 'w') as f:
        f.write('package %s;\n' % pkg)
        f.write('import crossj.base.Bytes;\n')
        f.write('public final class %s {\n' % shortname)
        f.write('  private %s(){}\n' % shortname)
        f.write('  private static final Bytes DATA = Bytes.ofU8s(')
        with open(path, 'rb') as inputfile:
            data = inputfile.read()
        first = True
        for b in data:
            if not first:
                f.write(',')
            first = False
            f.write(str(b))
        f.write(');\n')
        f.write('  public static Bytes getData() { return DATA; }\n')
        f.write('}\n')

    return True


def compute_shortname(path: str):
    filename = basename(path)
    assert '.java.' in filename, filename
    shortname = filename[:filename.index('.java.')]
    assert '.' not in shortname, shortname
    return shortname


def compute_pkg(path: str, root: str):
    rpath = relpath(dirname(path), root)
    assert '.' not in rpath, rpath
    return rpath.replace(sep, '.')


def compute_outpath(path: str, root: str, outdir: str):
    rpath = relpath(path, root)
    if '.java.' not in rpath:
        return None
    outpath = join(outdir, rpath[:rpath.index('.java.') + len('.java')])
    return outpath

##############################
# Some tests makeshift tests
##############################

def assert_eq(a, b):
    assert a == b, [a, b]

assert_eq(compute_outpath('foo/bar/Main.java', 'foo', 'out'), None)
assert_eq(compute_outpath('foo/bar/Main.java.jpg', 'foo', 'out'), 'out/bar/Main.java')
assert_eq(compute_outpath('/foo/bar/Main.java.jpg', '/', 'out'), 'out/foo/bar/Main.java')
assert_eq(compute_outpath('/foo/bar/Main.java.jpg', '/', '/out'), '/out/foo/bar/Main.java')

assert_eq(compute_pkg('foo/bar/Main.java.jpg', 'foo'), 'bar')
assert_eq(compute_pkg('/foo/bar/Main.java.jpg', '/'), 'foo.bar')

assert_eq(compute_shortname('/foo/bar/Main.java.jpg'), 'Main')
assert_eq(compute_shortname('/foo/bar/Baz.java.png'), 'Baz')


if __name__ == '__main__':
    main()
